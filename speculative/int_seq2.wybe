# For the generator:
# def {generator} int_seq(start: int, end: int, ?val: int) {
#    (start < end)
#
#    generate {
#        ?val = start
#    ||
#        ?val = start + 1
#    ||
#        int_seq(start + 2, end, ?val)
#    }
#
#    generate {
#        ?parity = 0
#    ||
#        ?parity = 1
#   }
#
#    ?val = val + parity + 1
#
# }

# Transformation to Det/SemiDet Wybe code:

# Translating the second generator. First proc just generates choicepoint.

# Second proc takes in choicepoint and generates all other solutions, with
# new choicepoint.

def {test} gen2_next(?parity:int, !cp:gen2cp) {
    if {cp = gen2_choice1::
        ?parity = 0
        ?cp = gen2_choice2
    |   cp = gen2_choice2::
        ?parity = 1
        ?cp = gen2_nomore
    |   otherwise:: fail
    }
}

pub type gen2cp { pub gen2_choice1 | gen2_choice2 | gen2_nomore }


# Translating the first generator. First proc generates the first solution,
# plus a choicepoint.

# Second proc takes in choicepoint and generates all other solutions, with
# new choicepoint.

def {test} gen1_next(start:int, end:int, ?val:int, !cp:gen1cp) {
    if {cp = gen1_choice1::
        ?val = start
        ?cp = gen1_choice2
    |   cp = gen1_choice2::
        ?val = start + 1
        ?cp = gen1_choice3(int_seq_entry)
    |   cp = gen1_choice3(?innercp)::
        if {int_seq(start + 2, end, ?val, !innercp)::
            ?cp = gen1_choice3(innercp)
        |   otherwise:: fail
        }
    |   otherwise:: fail
    }
}

pub type gen1cp { pub
              gen1_choice1
            | gen1_choice2
            | gen1_choice3(innercp:int_seq_cp)
            | gen1_nomore
            }


def {test} int_seq(start:int, end:int, ?val:int, !cp:int_seq_cp) {
    if {cp = int_seq_entry::
        (start < end)
        int_seq_cont1(start, end, ?val, gen1_choice1, !cp)
    |   cp = int_seq_retry(?cp1, ?cp2, ?val)::
        int_seq_cont2(start, end, val, ?val, cp1, cp2, !cp)
    |   otherwise:: fail
    }
}

def {test} int_seq_cont1(start:int, end:int, ?val:int,
                       cp1:gen1cp, !cp:int_seq_cp) {
    gen1_next(start, end, ?val0, !cp1)
    int_seq_cont2(start:int, end:int, val0:int,
                       ?val:int, cp1, gen2_choice1, !cp)
}


def {test} int_seq_cont2(start:int, end:int, val0:int, ?val:int,
                  cp1:gen1cp, cp2:gen2cp, !cp:int_seq_cp) {
    if {gen2_next(?parity, !cp2)::
        ?val = val0 + parity + 1
        ?cp = int_seq_retry(cp1, cp2, val0)
    |   otherwise::
        int_seq_cont1(start, end, ?val, cp1, !cp)
    }
}


pub type int_seq_cp { pub
    int_seq_entry
  | int_seq_retry(cp1:gen1cp, cp2:gen2cp, val:int)
}


# testing it:


?cp = int_seq_entry
do {while int_seq(1, 10, ?val, !cp)
    !println(val)
}
