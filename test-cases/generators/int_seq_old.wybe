# Code generation for the following generator:
# def {generator} int_seq(start: int, end: int, ?val: int) {
#     (start < end)
#     generate {
#         ?val = start
#     |>
#         ?val = start + 1
#     |>
#         int_seq(start + 2, end, ?val)
#     }
#     ?val = val + 1
# }

type State {
    pub State(start: int, end: int, altIndex: int)
}

def initAlternatives(start: int, end: int, ?state: State, ?val: int) {
    !logmsg("initAlternatives ->")
    !logmsg("start:")
    !logmsg(start)
    !lognl

    # Run first alternative
    ?val = start

    # State for next solution
    ?state = State(start, end, 1)
}

def {test} nextAlternative(!state: State, ?val: int) {
    (State(?start, ?end, ?altIndex) = state)

    !logmsg("nextAlternative ->")
    !logmsg("start:")
    !logmsg(start)
    !lognl

    ?val = 0

    if {
        altIndex = 1 ::
            ?val = start + 1
            ?state = State(start, end, 2)
        | altIndex = 2 ::
            initIntSeq(start + 2, end, ?val, ?state)
    }
}

def {test} initIntSeq(start: int, end: int, ?val: int, ?state: State) {
    (start < end)

    !logmsg("initIntSeq ->")
    !logmsg("start:")
    !logmsg(start)
    !lognl
    
    initAlternatives(start, end, ?state, ?val)

    ?val = val + 1
    !logmsg("Incrementing in initIntSeq->")
    !logmsg(val)
    !lognl
}

def {test} nextIntSeq(!state: State, ?val: int) {
    !logmsg("nextIntSeq ->")
    !logmsg("start:")
    !logmsg(start(state))
    !lognl

    nextAlternative(!state, ?val)
    ?val = val + 1
    !logmsg("Incrementing in nextIntSeq->")
    !logmsg(val)
    !lognl
}

# Code for corresponding for-loop
# for ?val in int_seq(0, 10) {
#    !println(val)
#}

if {
    initIntSeq(0, 10, ?val, ?state) ::
        do {
            !println(val)

            while nextIntSeq(!state, ?val)
        }
    | otherwise :: pass
}

