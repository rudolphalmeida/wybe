# For the generator:
# def {generator} int_seq(start: int, end: int, ?val: int) {
#    (start < end)
#
#    generate {
#        ?val = start
#    ||
#        ?val = start + 1
#    ||
#        int_seq(start + 2, end, ?val)
#    }
#
#    ?val = val + 1
#
# }


type State {
    pub StateAlt1(start: int, end: int)
      | StateAlt2(start: int, end: int)
      | StateAlt3(start: int, end: int, recursiveState: State)
      | Exhausted
}

def {test} init_IntSeq(start: int, end: int, ?state: State) {
    # Run the prelude
    (start < end)

    ?state = StateAlt1(start, end)
}

def {test} next_IntSeq(!state: State, ?val: int) {
    ?val = 0  # TODO: Figure out a way to get rid of this
    
    if {
        StateAlt1(?start, ?end) = state ::
            ?val = start
            ?state = StateAlt2(start, end)
        | StateAlt2(?start, ?end) = state ::
            ?val = start + 1
            if {
                init_IntSeq(start + 2, end, ?recursiveState) ::
                    ?state = StateAlt3(start, end, recursiveState)
                | otherwise ::
                    ?state = StateAlt3(start, end, Exhausted)
            }
        | StateAlt3(?start, ?end, ?recursiveState) = state ::
            if {
                next_IntSeq(!recursiveState, ?val) ::
                    ?state = StateAlt3(start, end, recursiveState)
                | otherwise ::
                    ?state = Exhausted
                    fail
            }
        | otherwise ::
            fail
    }

    # Run the postlude
    ?val = val + 1
}

if {
    init_IntSeq(0, 10, ?state) ::
        do {
            while next_IntSeq(!state, ?val)
            !println(val)
        }
}
