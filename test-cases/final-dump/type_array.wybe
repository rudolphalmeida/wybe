type raw_int_array is address {
    pub def raw_index(current: raw_int_array, index: int, size_in_bytes: int, ?ret_value: int) {
        foreign lpvm access(current, index * 8, size_in_bytes, 0, ?ret_value)
    }

    pub def raw_set(!current: raw_int_array, index: int, value: int, size_in_bytes: int) {
        foreign lpvm mutate(!current, index * 8, 1, size_in_bytes, 0, value)
    }

    pub def `=`(left: raw_int_array, right: raw_int_array, ?res:bool) {
        foreign llvm icmp eq(left, right, ?res)
    }
}

def alloc_raw_int_array(size: int, ?buffer: raw_int_array) {
    foreign lpvm alloc(size * 8, ?buffer:!raw_int_array)
}

pub type int_array {
    pub int_array(buffer: raw_int_array, size: int)

    pub def index(current: int_array, index: int, ?value: int) {
        buffer(current, ?raw_buffer)
        raw_index(raw_buffer, index, size(current) * 8, ?value)
    }

    pub def set(!current: int_array, index: int, value: int) {
        raw_set(buffer(current), buffer(!current), index, value, size(current) * 8)
    }

    # TODO: Raise an issue with a simpler type
    # Error detected during type checking of module(s) type_array, type_array.int_array, type_array.raw_int_array
    # test-cases/final-dump/type_array.wybe:33:9: Call from set to raw_set with 4 arguments, expected 5
    #pub def set(!current: int_array, index: int, value: int) {
    #    raw_set(buffer(!current), index, value, size(current) * 8)
    #}

    pub def test `=`(left: int_array, right: int_array) {
        int_array(?left_buffer, ?left_size, left)
        int_array(?right_buffer, ?right_size, right)

        (left_size = right_size)
        (left_buffer = right_buffer)
    }
}

pub def array(size: int, ?res_array: int_array) {
    ?raw_array = alloc_raw_int_array(size)
    ?res_array = int_array(raw_array, size)
}

pub type int_sequence {
    pub int_sequence(start: int, stride: int, end: int)

    pub def test `[|]`(?value: int, ?rest: int_sequence, current: int_sequence) {
        int_sequence(?s, ?st, ?en, current)

        if {
            st < 0 :: (s > en)
            | otherwise :: (s < en)
        }

        ?value = s
        ?rest = int_sequence(s + st, st, en)
    }
}

pub def xrange(start: int, stride: int, end: int): int_sequence =
    int_sequence(start, stride, end)

?a = array(10)

for i in xrange(0, 1, 10) {
    set(a, ?a, i, i)
    index(a, i, ?val)
    !println(val)
}
